#!/usr/bin/env python

import argparse
import logging
from pathlib import Path
import subprocess
import sys

project_dir = Path(__file__).parent.parent

xsl_dir = project_dir / "share"
grammar_dir = project_dir / "grammar"
lexicon_dir = project_dir / "lexicon"
build_dir = project_dir / "build"


def run(cmd, output_file=None, log_file=None, **args):
    "Run a subprocess, optionally redirecting stdout/stderr to files."
    logging.debug("! %s", cmd)

    args["capture_output"] = (
        args["capture_output"]
        if "capture_output" in args
        else (output_file is not None or log_file is not None)
    )

    try:
        result = subprocess.run(
            cmd,
            **args,
            check=True,
            text=True,
            encoding="utf-8",
        )

        if output_file is not None:
            output_file.write_text(result.stdout)
        if log_file is not None:
            log_file.write_text(result.stderr)

        return result
    except subprocess.CalledProcessError as e:
        if output_file is not None and e.stdout is not None:
            output_file.write_text(e.stdout)
        if log_file is not None and e.stderr is not None:
            log_file.write_text(e.stderr)
        raise


def saxon(xsl, *args, **kwargs):
    "Run an XSLT transformation via Saxon-HE."
    return run(
        [
            "java",
            "-Xmx8g",
            "-cp",
            "/usr/share/java/Saxon-HE.jar",
            "net.sf.saxon.Transform",
            f"-xsl:{xsl.as_posix()}",
            "-it",
            *args,
        ],
        **kwargs,
    )


def is_current(target, sources):
    "Check whether a target file is current, given the mtime of its sources."
    if not target.exists():
        return False
    target_m_time = target.stat().st_mtime
    return not any((target_m_time < source.stat().st_mtime for source in sources))


def has_sources(edition_dir):
    "Checks whether the source directory of an edition contains XML files."
    src_dir = edition_dir / "wb"
    for _source in src_dir.rglob("*.xml"):
        return True
    return False


def build_lexicon(edition_dir, force=False):
    "Builds the lexicon for an automaton edition."
    edition_name = edition_dir.name

    aux_dir = edition_dir / "aux"
    src_dir = edition_dir / "wb"
    exclude_file = edition_dir / "exclude.xml"
    sources = (
        list(aux_dir.rglob("*"))
        + list(src_dir.rglob("*"))
        + list(xsl_dir.rglob("*"))
        + [exclude_file]
    )

    edition_build_dir = build_dir / edition_name
    manifest_xml = edition_build_dir / "manifest.xml"
    manifest_log = edition_build_dir / "manifest.log"
    lex_txt = edition_build_dir / "lex.txt"
    lex_log = edition_build_dir / "lex.log"

    if not force and is_current(lex_txt, sources):
        logging.debug("Skip building lexicon '%s'", edition_name)
        return

    logging.info("Building lexicon '%s'", edition_name)
    edition_build_dir.mkdir(parents=True, exist_ok=True)
    saxon(
        xsl_dir / "dwds2manifest.xsl",
        f"dwds-dir={src_dir.as_posix()}",
        f"aux-dir={aux_dir.as_posix()}",
        f"exclude-file={exclude_file.as_posix()}",
        cwd=edition_dir,
        output_file=manifest_xml,
        log_file=manifest_log,
    )
    lexicon = saxon(
        xsl_dir / "dwds2dwdsmor.xsl",
        f"manifest-file={manifest_xml.as_posix()}",
        cwd=edition_dir,
        log_file=lex_log,
    )
    lex_txt.write_text("\n".join(sorted(set(lexicon.stdout.splitlines()))))


fst_sources = [
    fst_file
    for fst_file in grammar_dir.rglob("*.fst")
    if not fst_file.name.startswith("dwdsmor-")
]


def build_automaton(edition_dir, automaton_type, force=False):
    "Builds an automaton of the given type and edition."
    edition_name = edition_dir.name

    edition_build_dir = build_dir / edition_name

    lexicon_src = edition_build_dir / "lex.txt"
    automaton_src_tmpl = grammar_dir / f"dwdsmor-{automaton_type}.fst"
    automaton_a = edition_build_dir / f"{automaton_type}.a"
    automaton_ca = edition_build_dir / f"{automaton_type}.ca"

    sources = [lexicon_src, automaton_src_tmpl, *fst_sources]
    if (
        not force
        and is_current(automaton_a, sources)
        and is_current(automaton_ca, sources)
    ):
        logging.debug("Skip building automaton '%s/%s'", edition_name, automaton_type)
        return

    logging.info("Building automaton '%s/%s'", edition_name, automaton_type)
    automaton_src = grammar_dir / f"{edition_name}-{automaton_type}.fst"
    try:
        edition_build_dir.mkdir(parents=True, exist_ok=True)
        automaton_src_txt = automaton_src_tmpl.read_text(encoding="utf-8")
        automaton_src_txt = automaton_src_txt.replace(
            '$LEX$ = "dwds.lex"', f'$LEX$ = "{lexicon_src.as_posix()}"'
        )
        automaton_src.write_text(automaton_src_txt, encoding="utf-8")

        run(
            ["fst-compiler-utf8", automaton_src.as_posix(), automaton_a.as_posix()],
            cwd=grammar_dir,
        )
        run(["fst-compact", automaton_a.as_posix(), automaton_ca.as_posix()])
    finally:
        if automaton_src.is_file:
            automaton_src.unlink()


if __name__ == "__main__":
    arg_parser = argparse.ArgumentParser(description="Build DWDSmor automata.")
    arg_parser.add_argument(
        "editions", help="Editions to build (all by default)", nargs="*"
    )
    arg_parser.add_argument(
        "--automaton", help="Automaton type to build (all by default)", action="append"
    )
    arg_parser.add_argument("--debug", help="Print debug messages", action="store_true")
    arg_parser.add_argument(
        "--force", help="Force building (also outdated target)", action="store_true"
    )
    args = arg_parser.parse_args()

    logging.basicConfig(
        format="%(asctime)s - %(levelname)s - %(message)s",
        datefmt="%Y-%m-%d %H:%M:%S",
        stream=sys.stderr,
        level=(logging.DEBUG if args.debug else logging.INFO),
    )

    editions = (
        [lexicon_dir / edition for edition in args.editions]
        if len(args.editions or []) > 0
        else lexicon_dir.iterdir()
    )
    automaton_types = (
        args.automaton
        if len(args.automaton or []) > 0
        else ["finite", "index", "lemma", "morph", "root"]
    )
    for edition_dir in editions:
        assert edition_dir.is_dir()
        edition_name = edition_dir.name
        if not has_sources(edition_dir):
            logging.info("Skipping edition '%s' without sources", edition_name)
        build_lexicon(edition_dir, force=args.force)
        for automaton_type in automaton_types:
            build_automaton(edition_dir, automaton_type, force=args.force)
